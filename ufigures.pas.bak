unit UFigures;

{$mode objfpc}{$H+}

interface

uses
  Classes, SysUtils, Graphics, UScale, math, FPCanvas;

Type
  TFigure = class
    PenColor: TColor;
    BrushColor: Tcolor;
    Width: Integer;
    BrushStyle: TFPBrushStyle;
    PenStyle: TFPPenStyle;
    NumberOfAngles: Integer;
    Bounds : TDoubleRect;
    procedure Draw(Canvas: TCanvas); virtual; abstract;
  end;

  TPolyLine = class(TFigure)
    Points: array of TDoublePoint;
    procedure AddPoint(X, Y: Integer);
    procedure Draw(Canvas: TCanvas); override;
  end;

  TTwoPointsFigure = class(TFigure)
    //Bounds : TDoubleRect;
    procedure AddFirstPoint(X, Y: Integer);
    procedure AddSecondPoint(X, Y: Integer);
  end;

  { TTwoPointsFigure }

  TRectangle = class(TTwoPointsFigure)
    procedure Draw(Canvas: TCanvas); override;
  end;

  TEllipse = class(TTwoPointsFigure)
    procedure Draw(Canvas: TCanvas); override;
  end;

  TLine = class(TTwoPointsFigure)
    procedure Draw(Canvas: TCanvas); override;
  end;

  TFrame = class(TTwoPointsFigure)
    procedure Draw(Canvas: TCanvas); override;
  end;

  TPolygon = class(TTwoPointsFigure)
    procedure Draw(Canvas: TCanvas); override;
  end;


implementation


  { PolyLine }

procedure TPolyLine.AddPoint(X, Y: Integer);
begin
  SetLength(Points, Length(Points) + 1);
  Points[High(Points)] := ScreenToWorld(X,Y);
  UScale.FindBorderCoords(X, Y);
end;

procedure TPolyLine.Draw(Canvas: TCanvas);
begin
  Canvas.Pen.Color   := PenColor;
  Canvas.Brush.Color := BrushColor;
  Canvas.Pen.Width   := Width;
  Canvas.Pen.Style   := PenStyle;
  Canvas.Polyline(WorldPointsToScreen(Points));
end;

  { TTwoPointsFigure }

procedure TTwoPointsFigure.AddFirstPoint(X, Y: Integer);
begin
  Bounds := DoubleRect(ScreenToWorldX(X), ScreenToWorldY(Y),
                       ScreenToWorldX(X), ScreenToWorldY(Y));
end;

procedure TTwoPointsFigure.AddSecondPoint(X, Y: Integer);
begin
  Bounds := DoubleRect(Bounds.Left,       Bounds.Top,
                       ScreenToWorldX(X), ScreenToWorldY(Y));
end;

  { TRectangle }

procedure TRectangle.Draw(Canvas: TCanvas);
begin
  Canvas.Pen.Color   := PenColor;
  Canvas.Brush.Color := BrushColor;
  Canvas.Pen.Width   := Width;
  Canvas.Brush.Style := BrushStyle;
  Canvas.Pen.Style   := PenStyle;
  Canvas.Rectangle(WorldToScreen(Bounds));
end;

  { TEllipse }

procedure TEllipse.Draw(Canvas: TCanvas);
begin
  Canvas.Pen.Color   := PenColor;
  Canvas.Brush.Color := BrushColor;
  Canvas.Pen.Width   := Width;
  Canvas.Brush.Style := BrushStyle;
  Canvas.Pen.Style   := PenStyle;
  Canvas.Ellipse(WorldToScreen(Bounds));
end;

  { TLine }

procedure TLine.Draw(Canvas: TCanvas);
begin
  Canvas.Pen.Color   := PenColor;
  Canvas.Brush.Color := BrushColor;
  Canvas.Pen.Width   := Width;
  Canvas.Pen.Style   := PenStyle;
  Canvas.Line(WorldToScreen(Bounds));
end;

  { TFrame }

procedure TFrame.Draw(Canvas: TCanvas);
begin
  Canvas.Pen.Color := clBlack;
  Canvas.Pen.Width := 1;
  Canvas.Frame(WorldToScreen(Bounds));
end;

  { TPolygon }

procedure TPolygon.Draw(Canvas: TCanvas);
var
  i: Integer;
  MidlCoord: TDoublePoint;
  R: Double;
  Angles: array of TDoublePoint;
begin
  {Canvas.Pen.Color   := PenColor;
  Canvas.Brush.Color := BrushColor;
  Canvas.Pen.Width   := Width;
  Canvas.Brush.Style := BrushStyle;
  Canvas.Pen.Style   := PenStyle;}
  Canvas.Pen.Color   := clBlack;   //debag
  Canvas.Brush.Color := clBlack;
  Canvas.Pen.Width   := 4;
  Canvas.Brush.Style := bsSolid;
  Canvas.Pen.Style   := psSolid;
  begin
    MidlCoord.X := (Bounds.Left + Bounds.Right) / 2;
    MidlCoord.Y := (Bounds.Top + Bounds.Bottom) / 2;
    R := Min(Bounds.Right - MidlCoord.X, Bounds.Bottom - MidlCoord.Y);
    SetLength(Angles, NumberOfAngles);
    for i := 0 to NumberOfAngles - 1 do begin
      Angles[i].x := MidlCoord.X + (R*sin(i * 2 * pi / NumberOfAngles));
      Angles[i].y := MidlCoord.Y + (R*cos(i * 2 * pi / NumberOfAngles));
    end;
  end;
  Canvas.Polygon(WorldToScreen(Angles));
end;

end.

