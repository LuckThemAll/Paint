unit UScale;

{$mode objfpc}{$H+}

interface

uses
  Classes, SysUtils, math;

type

  TDoublePoint = record
    X: Double;
    Y: Double;
  end;

  TDoubleRect = record
    case Integer of
      0: (
          Left: Double;
          Top: Double;
          Right: Double;
          Bottom: Double;
        );
      1: (
          TopLeft: TDoublePoint;
          BottomRight: TDoublePoint;
        );
  end;

  TArrayOfTPoint = array of TPoint;

function DoublePoint(AX, AY: Double): TDoublePoint;
function DoubleRect(ATopLeft, ABottomRight: TDoublePoint): TDoubleRect;
function DoubleRect(ALeft, ATop, ARight, ABottom: Double): TDoubleRect;
function WorldPointsToScreen(APoints: array of TDoublePoint): TArrayOfTpoint;
function WorldToScreen(ADoubleRect: TDoubleRect): TRect;
function ScreenToWorld(AX, AY: Integer): TDoublePoint;
function ScreenToWorldX(AX: Integer): Double;
function ScreenToWorldY(AY: Integer): Double;
procedure ChangeScreenCoords(AX, AY: Double);
procedure SetScreenCoords(AX, AY: Double);
procedure SetScale(AScale: Double; AMidX, AMidY: integer);
procedure FindBorderCoords(AX, AY: integer);
procedure FindCanvasCoords(ARect: TDoubleRect);
procedure SetCoordsForBars(ACanvasCoords, AImageCoords: TDoubleRect);

var
  Scale: Double = 1.0;
  ScreenCoords: TDoublePoint;
  ImageCoords, CanvasCoords: TDoubleRect;


implementation

  { DoublePoint }

function DoublePoint(AX, AY: Double): TDoublePoint;
begin
  with Result do
  begin
    X := AX;
    Y := AY;
  end;
end;

  { TDoubleRect }

function DoubleRect(ALeft, ATop, ARight, ABottom: Double): TDoubleRect;
begin
  with Result do begin
    Left := ALeft;
    Top := ATop;
    Right := ARight;
    Bottom := ABottom;
  end;
end;

function DoubleRect(ATopLeft, ABottomRight: TDoublePoint): TDoubleRect;
begin
  with Result do begin
    TopLeft := ATopLeft;
    BottomRight := ABottomRight;
  end;
end;

  { ScreenCoords }

procedure SetScreenCoords(AX, AY: Double);
begin
  ScreenCoords.X := AX * Scale;
  ScreenCoords.Y := AY * Scale;
end;

procedure ChangeScreenCoords(AX, AY: Double);
begin
  ScreenCoords.X += Scale * AX;
  ScreenCoords.Y += Scale * AY;
end;

procedure SetScale(AScale: Double; AMidX, AMidY: integer);
var
  TempMidCoords: TDoublePoint;
begin
  TempMidCoords := ScreenToWorld(AMidX, AMidY);
  Scale := EnsureRange(AScale, 0.01, 20);
  UScale.ChangeScreenCoords(TempMidCoords.X - ScreenToWorldX(AMidX),
    TempMidCoords.Y - ScreenToWorldY(AMidY));
end;

procedure FindBorderCoords(AX, AY: integer);
begin
  if ImageCoords.Left > ScreenToWorldX(AX) then
    ImageCoords.Left := ScreenToWorldX(AX);
  if ImageCoords.Top > ScreenToWorldY(AY) then
    ImageCoords.Top := ScreenToWorldY(AY);
  if ImageCoords.Right < ScreenToWorldX(AX) then
    ImageCoords.Right := ScreenToWorldX(AX);
  if ImageCoords.Bottom < ScreenToWorldY(AY) then
    ImageCoords.Bottom := ScreenToWorldY(AY);
end;

procedure FindCanvasCoords(ARect: TDoubleRect);
begin
  if ARect.Left < CanvasCoords.Left then
    CanvasCoords.Left:=ARect.Left;
  if ARect.Top < CanvasCoords.Top then
    CanvasCoords.Top:=ARect.Top;
  if ARect.Right > CanvasCoords.Right then
    CanvasCoords.Right:=ARect.Right;
  if ARect.Bottom > CanvasCoords.Bottom then
    CanvasCoords.Bottom:=ARect.Bottom;
end;

procedure SetCoordsForBars(ACanvasCoords, AImageCoords: TDoubleRect);
begin
  if CanvasCoords.Left > ImageCoords.Left then
    CanvasCoords.Left := ImageCoords.Left - 10;
  if CanvasCoords.Top > ImageCoords.Top then
    CanvasCoords.Top := ImageCoords.Top - 10;
  if CanvasCoords.Right < ImageCoords.Right then
    CanvasCoords.Right := ImageCoords.Right + 30;
  if CanvasCoords.Bottom < ImageCoords.Bottom then
    CanvasCoords.Bottom := ImageCoords.Bottom + 30;
end;

  { Screen -> World}

function ScreenToWorld(AX, AY: Integer): TDoublePoint;
begin
  with Result do begin
    X := (AX + ScreenCoords.X) / Scale;
    Y := (AY + ScreenCoords.Y) / Scale;
  end;
end;

function ScreenToWorldX(AX: Integer): Double;
begin
  Result := (AX + ScreenCoords.X) / Scale;
end;

function ScreenToWorldY(AY: Integer): Double;
begin
  Result := (AY + ScreenCoords.Y) / Scale;
end;

  { World -> Screen }

function WorldToScreen(ADoublePoint: TDoublePoint): TPoint;
begin
  with Result do begin
    x := round(Scale * ADoublePoint.X - ScreenCoords.X);
    y := round(Scale * ADoublePoint.Y - ScreenCoords.Y);
  end;
end;

function WorldToScreen(ADoubleRect: TDoubleRect): TRect;
begin
  with Result do begin
    TopLeft := WorldToScreen(ADoubleRect.TopLeft);
    BottomRight := WorldToScreen(ADoubleRect.BottomRight);
  end;
end;

function WorldPointsToScreen(APoints: array of TDoublePoint): TArrayOfTpoint;
var
  i: Integer;
  TempPoints: TArrayOfTpoint;
begin
  SetLength(TempPoints, Length(APoints));
  for i := 0 to High(APoints) do begin
    TempPoints[i] := WorldToScreen(APoints[i]);
  end;
  Result := TempPoints;
end;

initialization
SetScreenCoords(0, 0);
ImageCoords.Left := 999999;
ImageCoords.Top := 999999;
end.

